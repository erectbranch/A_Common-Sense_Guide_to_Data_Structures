## 2.1 정렬된 배열(ordered array)
1장에서 설명한 배열과 거의 비슷하지만, 값이 항상 순서대로 있어야 한다는 점이 다르다. 즉, 값을 추가할 때마다 적절한 셀에 넣어 배열의 값을 정렬된 상태로 유지한다.

배열 [3, 17, 80, 202]를 예로 들자.

![그림 2-1](image_2-1.png)

75를 삽입해 보자. 일반적인 배열이면 다음처럼 끝에 75를 삽입할 것이다.

![그림 2-2](image_2-2.png)

반면 정렬된 배열에서는 값을 오름차순으로 유지하려면 적절한 위치에 75를 삽입하여야 한다.

![그림 2-3](image_2-3.png)

이 과정을 제대로 살펴 보자.

1. 인덱스 0의 값을 확인해서 삽입하려는 값인 75가 왼쪽에 들어가야 하는지, 오른쪽에 들어가야 하는지 결정한다.

![그림 2-5](image_2-5.png)

2. 다음 셀의 값(17)을 확인하다. 75는 17보다 크므로 또 다음 셀을 확인해야 한다.

3. 다음 셀의 값(80)을 확인한다. 75보다 큰 값이므로 이 자리에 데이터를 넣어야 한다. 따라서 80 이후의 값을 모두 오른쪽으로 옮겨야 한다.

4. 80이 들어갈 자리를 만들기 위해 마지막 값(202)을 오른쪽으로 옮긴다.

5. 80을 오른쪽으로 옮긴다.

![그림 2-9](image_2-9.png)

6. 75를 올바른 위치에 삽입한다.


이처럼 삽입 과정에서 배열보다 덜 효율적인 것을 확인할 수 있지만, 정렬된 배열의 강력함은 검색 연산에서 들어난다.


---


## 2.2. 정렬된 배열의 검색
배열과 정렬된 배열에서 선형 검색이 어떻게 다른지 보자.

[17,3,75,202,80]이라는 일반적인 배열이 있다고 하자. 배열에서는 (배열에 없는) 22라는 값을 찾으려면 22가 배열에 없을 수도 있으므로 모든 원소를 하나도 빠짐 없이 검색해야 한다.

하지만 정렬된 배열에서는 값이 배열에 들어있지 않을 때 검색을 더 빨리 멈출 수 있다. 정렬된 배열 [3, 17, 75, 80, 202]에서 22를 찾는다고 하면, 75에 도달했을 때 22가 없다는 사실을 알 수 있기 때문에 검색을 멈출 것이다.

다음은 루비로 구현한 배열의 선형 검색이다

```Ruby
def linear_search(array, value)
# 배열의 모든 원소를 순회한다.
array each do [element]

# 원하는 값을 찾으면 반환한다.
    if element == value
        return value

# 찾고 있던 값보다 큰 원소에 도달하면
# 루프를 일찍 종료할 수 있다.

    elsif element > value
        break
    end
 end

#배열에서 값을 찾지 못하면 널을 반환한다.
 return nil
end

```

이러한 관점에서 볼 때 선형 검색은 대부분의 경우에서 일반 배열보다 정렬된 배열에서 효율적으로 진행된다. 하지만 찾으려는 값이 제일 큰 마지막 값이거나 마지막 값보다 크면 마찬가지로 모든 셀을 검색해야 끝난다.

지금은 대단한 차이가 없어 보이지만, 이는 아직 선형 검색만 보았기 때문이다. 선형 검색은 사실 가능한 알고리즘 중 하나일 뿐이고 정렬된 배열이 배열보다 크게 두드러지는 장점은 다른 검색 알고리즘을 쓸 수 있다는 점이다. 이러한 알고리즘은 이진 검색(binary search)라고 하며, 이진 검색은 선형 검색보다 훨씬 빠르다.


---


## 2.3 이진 검색
1와 10 사이의 수를 맞춘다고 가정하고 알아맞추기 게임을 해보자

![그림 2-11](image_2-11.png)

위 과정이 이진 검색이다. 배열과 달리 선형 검색은 이진 검색을 수행할 수 있다는 큰 장점이 있다. 

실제 예제로 확인하자. 원소 9개를 포함하는 정렬된 배열이 있다고 하자. 컴퓨터는 각 셀에 어떤 값이 있는지 알 수 없으므로 아래와 같이 배열을 묘사하겠다.

![그림 2-12](image_2-12.png)

정렬된 배열에서 값 7을 찾는다고 하자. 이진 검색을 사용하자.

1. 가운데 셀부터 검색을 시작한다. 배열의 길이를 알고 있으므로 가운데 셀에 쉽게 접근할 수 있고, 길이를 2로 나누면 적절한 메모리 주소로 바로 이동할 수 있다. 가운데 셀의 값을 확인한다.

![그림 2-13](image_2-13.png)

값이 9로 드러났으므로 7은 왼쪽 어딘가에 있다고 판단할 수 있다. 따라서 오른쪽은 더 이상 살필 필요가 없다.

![그림 2-14](image_2-14.png)

2. 9보다 왼쪽에 있는 셀의 가운데 값을 확인한다. 가운데 값이 두 개이므로 임의의 왼쪽 값을 선택한다.

![그림 2-15](image_2-15.png)

이 셀의 값은 4이다. 따라서 7은 오른쪽 어딘가에 있을 것이다. 4의 왼쪽 셀은 더 이상 살필 필요가 없다.

![그림 2-16](image_2-16.png)

3. 7일 수 있는 셀이 두 개 남았다. 임의로 왼쪽 셀을 선택한다.

![그림 2-17](image_2-17.png)

4. 마지막 남은 셀을 확인한다.(여기에 7이 없다면 이 정렬된 배열에는 7이 없다는 뜻이다.)

![그림 2-18](image_2-18.png)

비록 선형 검색과 같은 수의 단계가 소요되었지만 이진 검색의 강력함은 더 확인할 것이다.

다음은 루비로 구현한 이진 검색이다.

```Ruby
def binary_search(array, value)

# 먼저 찾으려는 값이 있을 수 있는 상한선과 하한선을 정한다.
# 최초의 상한선은 배열의 첫번째 값, 하한선은 마지막 값이다.

lower_bound = 0
upper_bound = array.length - 1

# 상한선과 하한선 사이의 가운데 값을 계속해서 확인하는 루프를 시작한다.

    while lower_bound <= upper_bound do

# 상한선과 하한선 사이에 중간 지점을 찾는다.
# (결괏값이 정수가 아닐까 걱정할 필요는 없다.
# 루비는 정수를 나누기할 때 결과값을 가장 가까운 정수로 올림한다.)

midpoint = (upper_bound + lower_bound) / 2

# 중간 지점의 값을 확인한다.

value_at_midpoint = array[midpoint]

# 중간 지점의 값이 찾던 값이면 검색을 마친다.
# 그렇지 않다면 더 클지 작을지 추측한 바에 따라 상한선이나 하한선을 바꾼다.

    if value < value_at_midpoint
        upper_bound = midpoint - 1
    elsif value > value_at_midpoint
        lower_bound = midpoint + 1
    elsif value == value_at_midpoint
        return midpoint
    end
   end

# 상한선과 하한선이 같아질 때까지 경계값을 줄였다면
# 찾고 있는 값이 이 배열 안에 없다는 것과 같다.

 return nil
end
```

---


## 2.4 이진 검색 대 선형 검색
작은 크기의 정렬된 배열이라면 이진 검색 알고리즘이 선형 검색 알고리즘보다 크게 나은 점이 없다. 하지만 배열이 커지면 이야기가 다른다.

100개의 값을 갖는 배열이 있다면 각 검색에 필요한 최대 단계 수는 다음과 같다.

* 선형 검색: 100단계
* 이진 검색: 7단계

선형 검색에서는 찾고 있는 값이 마지막 셀에 있거나 마지막 셀의 값보다 크면 모든 원소를 조사해야 한다.

하지만 이진 검색을 쓰면 추측할 떄마다 검색해야 할 셀 중 절반을 제거할 수 있다.

![그림 2-19](image_2-19.png)


---