<div width="100%" height="100%" align="center">
  
<h1 align="center">
  <p align="center">누구나 자료 구조와 알고리즘</p>
  <a href="https://docusaurus.io">
    <img width="50%" src="cover.jpg" />
  </a>
</h1>
  
  
<b>브렛 슬라킨 저 · 오현석 역</b></br>
길벗 · 2020년 10월 30일 출시</b> 

</div>

## :bulb: 목표

- **자료 구조와 알고리즘 선택 방법을 배운다.**

  > 어떤 문제를 두고 배열, 연결 리스트, 해시 중에 무엇을 선택해야 하는지, 왜 그게 최적의 방법인지 공부하기

- **재귀 알고리즘 맛보기.**

  > 재귀적 반복 예시 코드를 익히며 성능에 미치는 영향을 확인하기

- **더 효율적인 코드를 구분하는 방법을 배운다.**

  > 시간 복잡도, 공간 복잡도 등 코드의 효율성을 나타내는 개념을 익히고 분석하기


</br>


## :mag: 목차

1장 자료 구조가 중요한 까닭

1.1 배열: 기초 자료 구조

1.2 읽기


1.3 검색

1.4 삽입

1.5 삭제

1.6 집합: 단 하나의 규칙이 효율성을 바꾼다

1.7 마무리


2장 알고리즘이 중요한 까닭

2.1 정렬된 배열

2.2 정렬된 배열의 검색

2.3 이진 검색

2.4 이진 검색 대 선형 검색

2.5 마무리


3장 빅 오 표기법

3.1 빅 오: 단계 수 계산

3.2 상수 시간과 선형 시간

3.3 같은 알고리즘, 다른 시나리오

3.4 세 번째 유형의 알고리즘

3.5 로가리즘

3.6 O(log N) 해석

3.7 실제 예제

3.8 마무리


4장 빅 오로 코드 속도 올리기

4.1 버블 정렬

4.2 버블 정렬 실제로 해보기

4.3 버블 정렬 구현

4.4 버블 정렬의 효율성

4.5 이차 문제

4.6 선형 해결법

4.7 마무리


5장 빅 오를 사용하거나 사용하지 않는 코드 최적화

5.1 선택 정렬

5.2 선택 정렬 실제로 해보기

5.3 선택 정렬 구현

5.4 선택 정렬의 효율성

5.5 상수 무시하기

5.6 빅 오의 역할

5.7 실제 예제

5.8 마무리


6장 긍정적인 시나리오 최적화

6.1 삽입 정렬

6.2 삽입 정렬해보기

6.3 삽입 정렬 구현

6.4 삽입 정렬의 효율성

6.5 평균적인 경우

6.6 실제 예제

6.7 마무리


7장 해시 테이블로 매우 빠른 룩업

7.1 해시 테이블 소개

7.2 해시 함수로 해싱

7.3 재미와 이익, 특히 이익을 남길 유의어 사전 만들기

7.4 충돌 해결

7.5 훌륭한 충돌 조정

7.6 실제 예제

7.7 마무리


8장 스택과 큐로 간결한 코드 생성

8.1 스택

8.2 스택 다뤄보기

8.3 큐

8.4 큐 다뤄보기

8.5 마무리


9장 재귀를 사용한 재귀적 반복

9.1 루프 대신 재귀

9.2 기저 조건

9.3 재귀 코드 읽기

9.4 컴퓨터의 눈으로 바라본 재귀

9.5 재귀 다뤄보기

9.6 마무리


10장 속도를 높이는 재귀 알고리즘

10.1 분할

10.2 퀵 정렬

10.3 퀵 정렬의 효율성

10.4 최악의 시나리오

10.5 퀵 셀렉트

10.6 마무리


11장 노드 기반 자료 구조

11.1 연결 리스트

11.2 연결 리스트 구현

11.3 읽기

11.4 검색

11.5 삽입

11.6 삭제

11.7 연결 리스트 다뤄보기

11.8 이중 연결 리스트

11.9 마무리


12장 이진 트리로 속도 향상

12.1 이진 트리

12.2 검색

12.3 삽입

12.4 삭제

12.5 이진 트리 다뤄보기

12.6 마무리


13장 그래프로 뭐든지 연결하기

13.1 그래프

13.2 너비 우선 탐색

13.3 그래프 데이터베이스

13.4 가중 그래프

13.5 데이크스트라의 알고리즘

13.6 마무리


14장 공간 제약 다루기

14.1 공간 복잡도에 빅 오 표기법 적용

14.2 시간과 공간 트레이드오프

14.3 마치면서

</br>