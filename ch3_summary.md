# 3 빅오 표기법
앞서 알고리즘의 효율성을 결정하는 주된 요인은 알고리즘 수행에 필요한 단게 수였다. 하지만 어떤 알고리즘을 "22단계의 알고리즘", "400단계의 알고리즘"이라 표시할 수는 없다. 이런 시간 복잡도를 쉽게 소통할 목적으로 수학적 개념을 차용했는데, 이러한 개념을 형식화한 표현을 '빅 오 표기법'이라 부른다.

---


## 3.1 빅 오: 단계 수 계산
빅 오는 시간 단위가 아닌 알고리즘에 필요한 단계 수만을 고려함으로써 일관성을 유지한다.

배열 읽기를 예시로 들자. 배열 읽기(1.1)에서 필요한 단계 수는 배열의 크기와 관계 없이 단 한 단계였다. 이를 빅 오 표기법으로 표현하면 다음과 같다.
> O(1)

일반적으로 "빅 오 1"이라고 발음한다. "차수 1"이라고도 부른다. 지금 책에서는 "오 1"이라고 부를 것이다. 부르는 방법은 다양하지만 표기법은 하나이다.

O(1)은 데이터 크기에 상관없이 알고리즘에 필요한 단계 수가 일정하다는 의미다. 배열 읽기는 배열에 얼마나 많은 데이터가 들어 있든 한 단계면 된다. 마찬가지로 배열 끝의 삽입, 삭제도 O(1)으로 표기할 수 있다

다른 예시로 빅 표 표기법으로 선형 검색의 효율성을 표현하는 방법을 알아보자. 선형 검색은 한 번에 한 셀씩 확인해서 배열에서 특정 값을 검색한다
>O(N)


---


## 3.2 상수 시간과 선형 시간
O(N) 알고리즘은 데이터 원소 수만큼의 단계가 필요하다. 따라서 배열에 원소 하나가 추가되면 O(N) 알고리즘은 한 단계 늘어난다 O(1) 알고리즘은 배열이 얼마나 커지든 단계 수가 같다.

![그림 3-1](image_3-1.png)

O(N)은 완벽한 대각선을 그린다. 이러한 특징 때문에 O(N)를 선형 시간(linear time)이라고 부른다.

이와 반대로 O(1)은 완벽한 수평선을 그린다. 이러한 특징 때문에 O(1)을 상수 시간(constant time)이라고도 부른다.

만약 데이터가 아무리 커지더라도 항상 (한 단계가 아니라) 세 단계가 걸리는 어떤 알고리즘이 있다고 하자. 이러한 알고리즘을 그래프로 보면 다음과 같다.

![그림 3-2](image_3-2.png)

데이터가 아무리 늘어나도 단계 수는 상수로 유지되므로 상수 시간이며, 빅 오 표기법으로는 O(1)이라 설명할 수 있다. 엄밀히 말하면 세 단계가 걸리지만 빅 오 표기법은 이를 사소하게 여긴다. **O(1)은 데이터가 아무리 커지더라도 단계 수가 변하지 않는 모든 알고리즘을 표현하는 방법이다.**

심지어 데이터가 아무리 커져도 100단계가 걸리는 알고리즘도 O(1)로 표현할 수 있다. 1단계로 끝나는 알고리즘보다 덜 효율적이지만 O(1)은 어떤 O(N)보다 효율적일 수 있다.

![그림 3-3](image_3-3.png)


---


## 3.3 같은 알고리즘, 다른 시나리오
선형 검색이 항상 O(N)은 아니다. 선형 검색에서 찾는 데이터가 인덱스 0에 있다면 한 단계만으로 끝나고, 맨 마지막에 있거나 없다면 N 단계로 끝날 것이기 때문이다. 그래도 빅 오 표기법으로 O(N)으로 표기한다. 빅오 표기법은 일반적으로 최악의 시나리오를 의미한다.

이는 <U>비관적인</U> 접근이 유용한 도구일 수 있기 때문이다. 최악의 시나리오에서 알고리즘이 얼마나 비효율적이지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있다.


---


## 3.4 세 번째 유형의 알고리즘
이제 이진 검색(2.3)을 빅 오 표기법 관점에서 어떻게 설명하는지 보자.

빅 오는 이진 검색의 시간 복잡도를 다음과 같이 설명한다
>O(log N)

"오 로그 N"으로 읽는다. 이러한 유형의 알고리즘을 로그 시간(log time)의 시간 복잡도라고 말한다.

간단히 말해 O(log N)은 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘을 설명하는 빅 오의 방법이다. 

![그림 3-4](image_3-4.png)


---


## 3.5 로가리즘
로그는 로가리즘(logarithm)의 줄임말이다. 로가리즘은 지수와 역(inverse)의 관계다. 간단한 예를 보자

* $2^3$은 2 * 2 * 2와 동치로 값은 8이다.

* $log_{2}{8}$은 $2^3$의 역(converse)이다. 즉, **2를 몇 번 곱해야 8을 얻을 수 있는지를 뜻한다.**

* 2를 세 번 곱해야 8이 나오므로 $log_{2}{8} = 3$이다.

로가리즘을 더 쉽게 이해하기 위해 $log_{2}{8}$을 다른 방식으로 설명하면,

**1이 될 때까지 8을 2로 계속해서 나눌 때 등식에 얼마나 많은 2가 등장할까?**

* 8/2/2/2 = 1

다시 말해 1이 나올 때까지 2는 3번 등장하므로 $log_{2}{8} = 3$이다.


---


## 3.6 O(log N) 해석
O(logN)은 사실 O($log_{2}N$)을 줄여 부르는 말이다. 단지 편의를 위해 다음 첨자 2를 생략했을 뿐이다.


---


### 3.7 실제 예제
다음은 리스트 내 모든 항목을 출력하는 전형적인 파이썬 코드다.

```Python
things = ['apples', 'baboons', 'cribs', 'dulcimers']

for thing in things:
    print("Here's a thing: %s" % thing)
```

이 알고리즘의 효율성을 빅 오 표기법으로 나타낸다면, 이 알고리즘은 O(N)이다.

```Python
print("Hello world!")
```

이 알고리즘은 항상 한 단계만 걸리므로 O(1)이다.

다음 예제는 주어진 수가 소수인지 알아보는 간단한 파이썬 기반 알고리즘이다.

```Python
def is_prime(number):
    for i in range(2, number):
        if number % i == 0:
            return False
    return True
```

이 알고리즘의 효율성은 O(N)이다. 숫자 7을 전달할 경우 for 루프는 2에서 시작해 실제 수 바로 전에 끝나므로 다섯 단계를 실행한다.


---