## 6.1 삽입 정렬
삽입 정렬(insersion sort)의 수행 순서는 다음과 같다.

1. 첫 번째 패스스루에서 임시로 인덱스 1(두 번째 셀)의 값을 삭제하고 이 값을 임시 변수에 저장한다. 인덱스 1에 값이 없으므로 공백이 생긴다.

![그림 6-1](image_6-1.png)

이후 각 패스스루마다 다음 인덱스의 값을 삭제한다.

2. 다음으로 공백 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작한다. 왼쪽에 있는 값이 임시 변수 값보다 크면 그 값을 오른쪽으로 시프트 한다.

![그림 6-3](image_6-3.png)

따라서 공백은 왼쪽으로 옮겨진다. 임시로 삭제한 값보다 작은 값을 만나거나 배열의 왼쪽 끝에 도달해야 시프트 단계가 끝난다.

3. 임시로 제거한 값을 현재 공백에 삽입한다.

![그림 6-4](image_6-4.png)

4. 배열이 완전히 정렬될 때까지 1단계부터 3단계를 반복한다.(두 번째 패스스루에서는 인덱스 2의 값을 임시로 삭제한 뒤 인덱스 1과 비교한다. 만약 인덱스 1에 있는 값이 삭제한 값보다 작다면 삭제했던 값을 다시 공백에 삽입한 후 두 번째 패스스루를 끝낸다.)


---


## 6.2 삽입 정렬해보기(생략)


---


## 6.3 삽입 정렬 구현
다음은 파이썬으로 구현한 삽입 정렬이다.

```Python
def insertion_sort(array):

    # 먼저 인덱스 1부터 시작해 전체 배열을 순회하는 루프를 시작
    for index in range(1, len(array)):

        # index가 무엇이든 인덱스를 position에 할당한다.
        # index에 저장된 값도 temp_value에 할당한다.
        position = index
        temp_value = array[index]

        # 안쪽 while 루프를 시작한다.
        # position의 왼쪽에 있는 값이 index에 있던 값보다 큰지 확인한다.
        while position > 0 and array[position - 1] > temp_value:

            # 왼쪽에 있는 값[position-1]이 크다면 왼쪽 값을 한 셀 오른쪽[position]으로 옮긴다.
            array[position] = array[position - 1]
            # 이후 position을 1 감소시킨다.
            # while문이므로 이 position에서 다시 이 과정을 반복한다.
            position = position - 1

        # 끝으로 삭제했던 temp_value 값을 배열의 공백에 삽입한다.
        array[position] = temp_value

```

---


## 6.4 삽입 정렬의 효율성
삽입 정렬에 포함된 단계는 삭제, 비교, 시프트, 삽입 네 종류다. 단계별로 살펴보자

1. 비교 

비교는 공백 왼쪽에 있는 값과 temp_value 값을 비교할 때마다 일어난다. 배열이 역순으로 정렬된 최악의 경우, 모든 수를 temp_value와 비교해야 한다. 

첫 번째 패스스루에서는 인덱스 1의 값이 temp_value이고 왼쪽 값이 하나만 존재하므로 1번의 비교가 일어난다. 두 번째 패스스루에서는 최대 2번, 세 번째는 최대 3번... 원소 N개의 배열에서 마지막인 N-1번째 패스스루에서는 최대 N-1번의 비교가 일어난다.

따라서 원소 N개의 배열에서 대략 $N^{2}/2$번의 비교가 일어난다.

2. 시프트

시프트는 값을 한 셀 오른쪽으로 옮길 떄마다 일어난다. 비교가 일어날 때마다 일어나므로 결국 비교 횟수만큼 일어난다. 따라서 최악의 시나리오라면 $N^{2}/2$번 시프트가 일어난다.

3. 삭제
4. 삽입

배열에서 temp_value를 삭제하고 다시 삽입하는 작업은 패스스루 당 한 번씩 일어난다. 따라서 각각 N-1번이다.

따라서 총합은 최악의 시나리오에서 $N^{2}/2$+$N^{2}/2$+(N-1)+(N-1)로 $N^{2}+2N-2$가 된다. 하지만 빅 오 표기법에는 다음과 같은 규칙이 있다.

> 빅 오 표기법은 가장 높은 차수의 N만 고려한다.

따라서 빅 오 표기법은 단순히 O($N^2$)이다. 언뜻 보면 삽입 정렬이 느려 보인다. 하지만 사실 그렇게 간단히 판단할 수 없다.


---


## 6.5 평균적인 경우
최악의 시나리오에서는 선택 정렬이 삽입 정렬보다 빠른 게 사실이다. 하지만 평균 시나리오도 중요하게 고려해야 한다. 정의에 따라서 평균 시나리오가 가장 자주 일어나기 때문이다.

![그림 6-29](image_6-29.png)

그렇다면 선택 정렬과 삽입 정렬 중 어떤 게 더 나을까? 이는 경우에 따라 다르다. 임의로 정렬된 배열 같은 평균적인 경우라면 두 정렬은 유사하게 수행된다. 거의 정렬된 데이터를 다룬다고 가정할 수 있다면 삽입 정렬이 더 낫다. 대부분 역순으로 정렬된 데리터를 다룰 거라고 가정할 수 있다면 선택 정렬이 더 빠르다. 데이터가 어떨지 전혀 알 수 없다면 기본적으로 평균적인 경우이며 둘 다 같다.


---


## 6.6 실제 예제
두 배열의 교집합을 구하는 자바스크립트 애플리케이션을 작성한다고 하자. 자바스크립트는 이러한 내장 함수를 제공하지 않으므로 사용자 스스로 만들어야 한다.

```Javascript
function intersection(first_array, second_array){
    
    var result = [];

    for (var i = 0; i < first_array.length; i++){
        for (var j = 0; j < second_array.length; j++){
            if (first_array[i] == second_array[j]){
                result.push(first_array[i]);
            }
        }
    }

    return result;

}

```

위 알고리즘은 비교와 삽입, 두 종류의 단계를 수행한다. 두 배열 내 모든 값을 서로 비교하고 값이 일치하면 result 배열에 삽입한다. 두 배열의 크기가 같다면 $N^2$ 번의 비교를 수행한다. 따라서 이러한 교집합 알고리즘의 효율성은 O($N^{2}$)이다.

그런데 이 알고리즘을 향상시킬 방법은 없을까?

바로 지금이 다른 시나리오를 고려해야 할 상황이다. 두 배열에 공통 원소가 있다면 첫 번재 배열의 모든 원소를 꼭 두 번째 배열의 모든 배열과 비교하지 않아도 된다.

![그림 6-31](image_6-31.png)

위 그림처럼 공통된 원소(8)을 찾았다면 그 뒤를 더 탐색하는 것은 무의미하다. 이는 한 단어만 추가하면 구현할 수 있다.

```Javascript
function intersection(first_array, second_array){
    
    var result = [];

    for (var i = 0; i < first_array.length; i++){
        for (var j = 0; j < second_array.length; j++){
            if (first_array[i] == second_array[j]){
                result.push(first_array[i]);
                break;
            }
        }
    }

    return result;

}

```

break를 추가함으로써 안쪽 루프를 짧게 끝내게 만들었다. 최악의 시나리오에서는 바뀌지 않겠지만 평균적인 시나리오에서는 N과 $N^2$ 사이쯤일 것이다.


---