# 누구나 자료 구조와 알고리즘
제이 웬그로우 지음


---


## 1.1 배열: 기초 자료 구조
데이터 원소들의 리스트

가령 마트에서 살 쇼핑 목록을 만들고 사용할 수 있는 애플리케이션의 소스 코드를 보자.

```
array = ["apples", "bananas", "cucumbers", "dates", "elderberries"]
```

* 배열에 들어 있는 다섯 가지 문자열은 마트에서 살 법한 식료품들이다.

* 배열의 인덱스는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자이다.

참고로 대부분의 프로그래밍 언어에서 <U>인덱스는 0부터 시작</U>한다.("apples":0, "elderberries":4)

![그림 1-1](image_1_1.png)
배열 같은 자료 구조의 성능을 알려면 코드가 자료 구조와 일반적으로 어떻게 상호 작용하는지 분석해야 한다.

대부분의 자료 구조는 네 가지 기본 방법을 사용하며, 이를 연산이라 부른다.

* 읽기: 읽기는 자료 구조 내 특정 위치를 찾아보는 것이다. 배열에서는 특정 인덱스의 값을 찾아보는 것을 뜻한다.
가령 인덱스 2에 들어 있는 물건을 찾는 것이 배열 읽기의 예이다.

* 검색: 검색은 자료 구조 내에서 특정 값을 찾는 것이다. 배열에서는 특정 값이 배열에 들어 있는지, 만약 그렇다면 어떤 인덱스에 있는지 찾아보는 것을 뜻한다.

* 삽입: 삽입은 자료 구조에 새로운 값을 추가하는 것이다. 배열이라면 배열 내에 슬롯을 더 만들어 새 값을 추가하는 것을 뜻한다. 
앞선 쇼핑 목록에 "figs"를 추가하는 게 배열에 새 값을 삽입하는 예이다.

* 삭제: 삭제는 자료 구조에서 값을 제거하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻한다.

1장에서는  각 연산을 배열에 적용했을 때 얼마나 빠르게 수행되는지 알아볼 것이다.(얼마나 많은 단계가 수행되는지를 알아볼 것이다.)


---

## 1.2 읽기
읽기는 배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾아보는 것이다. 컴퓨터는 어떻게 단 한 단계로 배열의 인덱스를 찾아볼 수 있을까?

컴퓨터의 메모리는 셀로 구성된 거대한 컬렉션이라 할 수 있다. 아래 예시 그림을 보자. 어떤 셀은 비어 있고, 어떤 셀에는 데이터가 들어 있다.

![그림 1-2](image_1-2.png)

프로그램에서 배열을 선언하면 컴퓨터는 프로그램이 쓸 수 있는 연속된 빈 셀들의 집합을 할당한다. 예를 들어 원소 다섯 개를 넣을 배열을 생성하면 컴퓨터는 한 줄에서 5개의 빈 셀 그룹을 찾아 사용자가 사용할 배열로 지정한다

![그림 1-3](image_1-3.png)

컴퓨터 메모리 내에 각 셀에는 특정 주소가 있다. 간단한 수로 표시한다는 점만 제외하면 일종의 거리 주소(강남로 123)와 비슷한다. 각 셀의 메모리 주소는 앞 셀의 주소+1이다. 

![그림 1-4](image_1-4.png)

이어지는 그림은 인덱스와 메모리 주소를 표시한 쇼핑 목록 배열이다.

![그림 1-5](image_1-5.png)

컴퓨터가 배열의 특정 인덱스에 있는 값을 읽을 때 바로 갈 수 있는 것은 다음과 같은 이유가 복합적으로 작용한다.

* 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.(강남로 123으로 가주세요.)

* 각 배열에 저장된 내용은 메모리의 시작 주소다. 따라서 컴퓨터는 손쉽게 시작 주소를 얻는다.

* 배열의 인덱스는 0부터 시작한다.

앞선 예제에서 컴퓨터에 인덱스 3에 있는 값(dates)를 읽으라고 명령하면 컴퓨터는 다음과 같은 과정을 밟는다.

1. 배열의 인덱스는 0부터 시작하며, 인덱스 0의 메모리 주소는 1010이다.

2. 인덱스 3은 인덱스 0에서 정확히 3 슬롯 뒤에 있다.

3. 따라서 인덱스 3이 있는 1010+3인 1013 메모리 주소로 간다.

이와 같이 '배열 **읽기**'는 한 단계 만에 끝나는 매우 효율적인 연산이다. 즉 가장 빠른 연산 유형이다. 배열이 그토록 강력한 자료 구조인 이유 중 하나는 어떤 인덱스의 값이든 빨리 찾을 수 있기 때문이다.


---


## 1.3 검색(선형 검색)
배열 검색은 배열에 특정 값이 있는지 알아본 후 있다면 어떤 인덱스에 있는지 찾는 것이다. 배열에서 값을 찾을 때 컴퓨터는 인덱스 0에서 시작해서 값을 확인한 후 찾는 값이 아니면 다음 인덱스로 이동한다. 이 과정은 찾고 있는 값을 발견할 때까지 계속된다.

예시에서 "dates"를 찾는다고 하자. 아래 예시 그림처럼 컴퓨터는 가장 먼저 인덱스 0을 확인한다.

![그림 1-6](image_1-6.png)

인덱스 0에 있는 값이 "apples"로 찾는 값이 아니므로 다음 인덱스인 인덱스 1로 이동해서 마찬가지로 확인한다. 이 역시 포함하지 않으므로 인덱스 2로 넘어간다. 이 과정을 반복해서

![그림 1-9](image_1-9.png)

드디어 찾던 "dates"를 찾았다. 이제 "dates"가 인덱스 3에 있는 것을 발견했으니 더 이상 배열의 다음 셀로 이동해서 검색을 계속할 필요가 없다.

예제에서는 값을 발견할 때까지 4개의 셀을 확인하였으므로 이 연산에서는 총 4단계가 걸렸다고 할 수 있다.

이와 같은 연산, 즉 컴퓨터가 한 번에 한 셀씩 확인하는 방법을 선형 검색이라고 한다.

그렇다면 컴퓨터가 배열에서 선형 검색을 수행하는 데 필요한 최대 단계 수는 얼마일까? 예를 들어 위 예제에서는 "elderberries"처럼 찾는 값이 배열 마지막 셀에 있다면, 컴퓨터는 결국 배열의 모든 셀을 검색해야 한다. 마찬가지로 데이터가 배열에 없으면 마찬가지로 모든 셀을 검색해야 비로소 배열에 값이 없다고 확신할 수 있다.

따라서 N개의 셀로 이뤄진 배열은 선형 검색에 최대 N개의 단계가 필요하다. 1.2절에서 한 읽기에 비해 덜 효율적인 것을 알 수 있다. 읽기는 배열이 얼마나 크든 항상 한 단계면 끝나지만 검색은 크기만큼 오래 걸리기 때문이다.


---


## 1.4 삽입
배열에 새 데이터를 삽입하는 연산은 배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.

예를 들어 쇼핑 목록 마지막에 "figs"를 추가해 보자. 이 삽입은 단 한 단계로 끝난다. 앞서 설명했듯 컴퓨터는 배열이 시작하는 메모리 주소를 안다. 컴퓨터는 배열이 현재 얼마나 많은 원소를 포함하는지도 알고 있기 때문에 새 원소를 추가해야 하는 메모리 주소가 어딘지 계산할 수 있고, 이는 한 단계면 된다.

![그림 1-10](image_1-10.png)

하지만 배열의 맨 처음이나 중간에 데이터를 삽입하면 문제가 달라진다. 이때는 삽입할 공간을 만들기 위해 많은 데이터 조각을 이동시켜야 한다.

예를 들어 배열의 인덱스 2에 "figs"를 추가해 보자.

![그림 1-11](image_1-11.png)

위와 같이 하려면 "cucumbers", "dates", "elderberries"를 오른쪽으로 옮겨야 한다. 하지만 여기서도 단계 몇 가지가 필요하다.

1. "elderberries"를 오른쪽으로 옮긴다.

2. "dates"를 오른쪽으로 옮긴다.

3. "cucumbers"를 오른쪽으로 옮긴다.

4. "figs"를 인덱스 2에 삽입한다.

![그림 1-15](image_1-15.png)

예제에서 4단계가 필요한 것을 보았다. 데이터를 오른쪽으로 옮기는 3단계와 데이터를 삽입하는 1단계이다.

따라서 배열 삽입에서 가장 많이 단계가 소요되는 시나리오는 데이터를 배열의 맨 앞에 삽입할 때다. 배열 내 모든 값을 한 셀씩 모두 오른쪽으로 옮겨야 하기 때문이다(N+1단계가 소요)


---


## 1.5 삭제
특정 인덱스의 값을 삭제하는 과정이다.

예제에서 인덱스 2의 "cucumbers" 값을 삭제한다고 하자.

1. 배열에서 "cucumbers"를 삭제한다.

![그림 1-16](image_1-16.png)

배열은 빈 공간을 허용하지 않으므로, 오른쪽에 있는 데이터를 모두 왼쪽으로 옮겨야 한다.

2. "dates"를 왼쪽으로 옮긴다.

3. "elderberries"를 왼쪽으로 옮긴다.

따라서 삭제 연산에 총 3단계가 필요했다. 삽입과 마찬가지로 배열에서 가장 많이 단계가 소요되는 시나리오는 배열의 맨 앞에 있는 데이터를 삭제할 때이다.

이처럼 특정 연산에서 효율성은 차이를 보인다. 사용자가 만든 프로그램에서 올바른 자료 구조의 선택이 코드의 성능에 중대한 영향을 미칠 수 있기 때문에 자료 구조의 선택은 중요하다. 이후로는 다른 연산에서 다른 효율성을 보이는 다른 자료 구조를 살필 것이다.


---


## 1.6 집합(배열 기반 집합)
집합은 중복 값을 허용하지 않는 자료 구조다. 다양한 집합이 있지만 여기서는 배열 기반 집합을 다룬다. 배열 기반 집합과 일반적인 배열 간 유일한 차이점은 중복 값의 삽입을 절대 허용하지 않는다는 점이다.

예를 들어 ["a", "b", "c"]라는 집합에 또 다른 "b"를 추가하려고 하면 컴퓨터는 "b"가 이미 있으므로 삽입을 허용하지 않는다.

즉, 집합은 중복 데이터가 없어야 할 때 유용하다.

예를 들어 온라인 전화번호부를 만든다면 같은 전화번호가 두 번 나와서는 안 된다.


### 1.6.1 읽기
집합 읽기는 배열 읽기와 완전히 동일하다. 컴퓨터가 특정 인덱스에 들어 있는 값을 찾는 데 단 한 단계면 충분하다.


### 1.6.2 검색
집합 검색도 배열 검색과 아무런 차이가 없다.


### 1.6.3 삭제
집합 삭제도 배열 삭제와 아무런 차이가 없다.


### 1.6.4 삽입
하지만 삽입만큼은 배열과 차이를 보인다. 배열에서 최선의 시나리오인 맨 끝에 데이터를 삽입하는 과정을 생각해 보자. 이 때 컴퓨터는 마지막에 데이터를 삽입하며 1단계로 끝냈다.

하지만 집합에서는 먼저 이 값이 이미 집합에 들어 있는지 확인해야 한다. 따라서 **집합 삽입에는 검색이 우선**이다.

만약 이전 예제에 "figs"를 삽입하려면, 먼저 검색을 수행해야 한다.

1. 인덱스 0에서 "figs"를 검색한다.

![그림 1-19](image_1-19.png)

2. 인덱스 1에서 검색한다.

3. 인덱스 2에서 검색한다.

4. 인덱스 3에서 검색한다.

5. 인덱스 4에서 검색한다.

6. 집합의 끝에 "figs"를 삽입한다.

바꿔 말해 집합 삽입에서 최선의 시나리오는 원소 N개에 대해 N+1단계가 필요하다.

집합 삽입에서 최악의 시나리오는 컴퓨터가 셀 N개를 모두 확인한 후, 맨 앞에 데이터를 넣기 위해 데이터 N개를 모두 오른쪽으로 옮기는 것이다. 그리고 마지막 단계에 데이터를 삽입하므로 N+N+1단계가 소요된다.

이처럼 집합은 일반적으로 배열보다 느리다. 중복 데이터가 없어야 할 때가 아니라면 배열이 나을 가능성이 높다.


---